package runtimeutil

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"strconv"
	"text/template"
)

const resolvConfTemplate = `# resolv.conf generated by ext.arhat.dev/runtimeutil
{{ range .Servers -}}
nameserver {{ . }}
{{ end -}}
search {{- range .Searches }} {{ . }} {{- end }}
{{ if gt (len .Options) 0 -}}
options {{- range .Options }} {{ . }} {{- end -}}
{{ end }}
`

// DelegateExecFunc execute abbot command with provided environment variables and io channel
type DelegateExecFunc func(env map[string]string, stdin io.Reader, stdout, stderr io.Writer) error

func NewNetworkClient(exec DelegateExecFunc) *NetworkClient {
	return &NetworkClient{
		execAbbot: exec,
	}
}

type NetworkClient struct {
	execAbbot DelegateExecFunc
}

func (c *NetworkClient) CreateResolvConf(nameservers, searches, options []string) ([]byte, error) {
	resolvTemplate, err := template.New("").Parse(resolvConfTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse resolv.conf template")
	}

	if len(nameservers) == 0 {
		nameservers = []string{"::1", "127.0.0.1"}
	}

	if len(searches) == 0 {
		searches = []string{"."}
	}

	buf := new(bytes.Buffer)
	err = resolvTemplate.Execute(buf, map[string][]string{
		"Servers":  nameservers,
		"Searches": searches,
		"Options":  options,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to execute resolve.conf template")
	}

	return buf.Bytes(), nil
}

func (c *NetworkClient) Do(
	ctx context.Context,
	abbotReqData []byte,
	pid int64,
	containerID string,
) (abbotRespData []byte, err error) {
	buf := new(bytes.Buffer)
	errBuf := new(bytes.Buffer)

	err = c.execAbbot(map[string]string{
		"ABBOT_REQ_CONTAINER_ID":  containerID,
		"ABBOT_REQ_CONTAINER_PID": strconv.FormatInt(pid, 10),
	}, bytes.NewReader(abbotReqData), buf, errBuf)
	if err != nil {
		return nil, err
	}

	errStr := errBuf.String()
	if len(errStr) != 0 {
		return nil, fmt.Errorf(errStr)
	}

	return buf.Bytes(), nil
}
